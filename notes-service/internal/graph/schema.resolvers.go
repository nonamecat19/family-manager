package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code
// will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/nnc/notes-manager-backend/internal/auth"
	"github.com/nnc/notes-manager-backend/internal/database/sqlc"
	"github.com/nnc/notes-manager-backend/internal/graph/model"
)

// --- Auth Mutations ---

func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	user, tokens, err := r.Auth.Register(ctx, input.Email, input.Username, input.Password)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		User:         userToModel(*user),
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, tokens, err := r.Auth.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		User:         userToModel(*user),
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	claims, err := r.JWT.ValidateToken(token)
	if err != nil {
		return nil, fmt.Errorf("invalid refresh token")
	}
	uid, err := stringToUUID(claims.UserID)
	if err != nil {
		return nil, err
	}
	user, err := r.Queries.GetUserByID(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}
	tokens, err := r.JWT.GenerateTokenPair(claims.UserID)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		User:         userToModel(user),
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

// --- List Mutations ---

func (r *mutationResolver) CreateList(ctx context.Context, input model.CreateListInput) (*model.List, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	uid, err := stringToUUID(userID)
	if err != nil {
		return nil, err
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}
	public := false
	if input.IsPublic != nil {
		public = *input.IsPublic
	}

	list, err := r.Queries.CreateList(ctx, sqlc.CreateListParams{
		OwnerID:     uid,
		Title:       input.Title,
		Description: desc,
		IsPublic:    public,
	})
	if err != nil {
		return nil, err
	}

	result := listToModel(list)
	result.Items = []*model.Item{}
	result.Tags = []*model.Tag{}
	return r.populateListOwner(ctx, result)
}

func (r *mutationResolver) UpdateList(ctx context.Context, id string, input model.UpdateListInput) (*model.List, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(id)
	if err != nil {
		return nil, err
	}
	existing, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}
	if uuidToString(existing.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	title := existing.Title
	if input.Title != nil {
		title = *input.Title
	}
	desc := existing.Description
	if input.Description != nil {
		desc = *input.Description
	}
	public := existing.IsPublic
	if input.IsPublic != nil {
		public = *input.IsPublic
	}

	list, err := r.Queries.UpdateList(ctx, sqlc.UpdateListParams{
		ID:          lid,
		Title:       title,
		Description: desc,
		IsPublic:    public,
	})
	if err != nil {
		return nil, err
	}
	return r.populateList(ctx, listToModel(list))
}

func (r *mutationResolver) DeleteList(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(id)
	if err != nil {
		return false, err
	}
	existing, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return false, fmt.Errorf("list not found")
	}
	if uuidToString(existing.OwnerID) != userID {
		return false, fmt.Errorf("forbidden")
	}

	err = r.Queries.DeleteList(ctx, lid)
	return err == nil, err
}

// --- Item Mutations ---

func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(input.ListID)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}
	if uuidToString(list.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	pos := int32(0)
	if input.Position != nil {
		pos = int32(*input.Position)
	}

	item, err := r.Queries.CreateItem(ctx, sqlc.CreateItemParams{
		ListID:   lid,
		Type:     modelItemTypeToDb(input.Type),
		Content:  input.Content,
		Position: pos,
	})
	if err != nil {
		return nil, err
	}
	return itemToModel(item), nil
}

func (r *mutationResolver) UpdateItem(ctx context.Context, id string, input model.UpdateItemInput) (*model.Item, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	iid, err := stringToUUID(id)
	if err != nil {
		return nil, err
	}
	existing, err := r.Queries.GetItemByID(ctx, iid)
	if err != nil {
		return nil, fmt.Errorf("item not found")
	}

	list, err := r.Queries.GetListByID(ctx, existing.ListID)
	if err != nil {
		return nil, err
	}
	if uuidToString(list.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	content := existing.Content
	if input.Content != nil {
		content = *input.Content
	}
	itemType := existing.Type
	if input.Type != nil {
		itemType = modelItemTypeToDb(*input.Type)
	}

	item, err := r.Queries.UpdateItem(ctx, sqlc.UpdateItemParams{
		ID:      iid,
		Content: content,
		Type:    itemType,
	})
	if err != nil {
		return nil, err
	}
	return itemToModel(item), nil
}

func (r *mutationResolver) DeleteItem(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}

	iid, err := stringToUUID(id)
	if err != nil {
		return false, err
	}
	existing, err := r.Queries.GetItemByID(ctx, iid)
	if err != nil {
		return false, fmt.Errorf("item not found")
	}

	list, err := r.Queries.GetListByID(ctx, existing.ListID)
	if err != nil {
		return false, err
	}
	if uuidToString(list.OwnerID) != userID {
		return false, fmt.Errorf("forbidden")
	}

	err = r.Queries.DeleteItem(ctx, iid)
	return err == nil, err
}

func (r *mutationResolver) ReorderItems(ctx context.Context, listID string, itemIDs []string) ([]*model.Item, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(listID)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}
	if uuidToString(list.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	for i, itemID := range itemIDs {
		iid, err := stringToUUID(itemID)
		if err != nil {
			return nil, err
		}
		if err := r.Queries.UpdateItemPosition(ctx, sqlc.UpdateItemPositionParams{
			ID:       iid,
			Position: int32(i),
		}); err != nil {
			return nil, err
		}
	}

	items, err := r.Queries.GetItemsByList(ctx, lid)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Item, len(items))
	for i, item := range items {
		result[i] = itemToModel(item)
	}
	return result, nil
}

// --- Tag Mutations ---

func (r *mutationResolver) AddTagToList(ctx context.Context, listID string, tagName string) (*model.List, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(listID)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}
	if uuidToString(list.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	tag, err := r.Queries.UpsertTag(ctx, tagName)
	if err != nil {
		return nil, err
	}

	err = r.Queries.AddTagToList(ctx, sqlc.AddTagToListParams{
		ListID: lid,
		TagID:  tag.ID,
	})
	if err != nil {
		return nil, err
	}

	return r.populateList(ctx, listToModel(list))
}

func (r *mutationResolver) RemoveTagFromList(ctx context.Context, listID string, tagName string) (*model.List, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	lid, err := stringToUUID(listID)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}
	if uuidToString(list.OwnerID) != userID {
		return nil, fmt.Errorf("forbidden")
	}

	tag, err := r.Queries.GetTagByName(ctx, tagName)
	if err != nil {
		return nil, fmt.Errorf("tag not found")
	}

	err = r.Queries.RemoveTagFromList(ctx, sqlc.RemoveTagFromListParams{
		ListID: lid,
		TagID:  tag.ID,
	})
	if err != nil {
		return nil, err
	}

	return r.populateList(ctx, listToModel(list))
}

// --- Upload ---

func (r *mutationResolver) UploadImage(ctx context.Context, file graphql.Upload) (string, error) {
	_, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return "", fmt.Errorf("unauthorized")
	}

	key, err := r.Storage.Upload(ctx, file.File, file.ContentType, file.Size)
	if err != nil {
		return "", err
	}
	return key, nil
}

// --- Queries ---

func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	uid, err := stringToUUID(userID)
	if err != nil {
		return nil, err
	}
	user, err := r.Queries.GetUserByID(ctx, uid)
	if err != nil {
		return nil, err
	}
	return userToModel(user), nil
}

func (r *queryResolver) List(ctx context.Context, id string) (*model.List, error) {
	lid, err := stringToUUID(id)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, fmt.Errorf("list not found")
	}

	// Check access: public lists are visible to anyone, private only to owner
	if !list.IsPublic {
		userID, ok := auth.UserIDFromContext(ctx)
		if !ok || uuidToString(list.OwnerID) != userID {
			return nil, fmt.Errorf("forbidden")
		}
	}

	return r.populateList(ctx, listToModel(list))
}

func (r *queryResolver) MyLists(ctx context.Context) ([]*model.List, error) {
	userID, ok := auth.UserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	uid, err := stringToUUID(userID)
	if err != nil {
		return nil, err
	}

	lists, err := r.Queries.GetListsByOwner(ctx, uid)
	if err != nil {
		return nil, err
	}

	result := make([]*model.List, len(lists))
	for i, l := range lists {
		m := listToModel(l)
		m, err = r.populateList(ctx, m)
		if err != nil {
			return nil, err
		}
		result[i] = m
	}
	return result, nil
}

func (r *queryResolver) PublicLists(ctx context.Context, limit *int, offset *int) ([]*model.List, error) {
	lim := int32(20)
	if limit != nil {
		lim = int32(*limit)
	}
	off := int32(0)
	if offset != nil {
		off = int32(*offset)
	}

	lists, err := r.Queries.GetPublicLists(ctx, sqlc.GetPublicListsParams{
		Limit:  lim,
		Offset: off,
	})
	if err != nil {
		return nil, err
	}

	result := make([]*model.List, len(lists))
	for i, l := range lists {
		m := listToModel(l)
		m, err = r.populateList(ctx, m)
		if err != nil {
			return nil, err
		}
		result[i] = m
	}
	return result, nil
}

func (r *queryResolver) Tags(ctx context.Context) ([]*model.Tag, error) {
	tags, err := r.Queries.GetAllTags(ctx)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Tag, len(tags))
	for i, t := range tags {
		result[i] = tagToModel(t)
	}
	return result, nil
}

func (r *queryResolver) Tag(ctx context.Context, name string) (*model.Tag, error) {
	tag, err := r.Queries.GetTagByName(ctx, name)
	if err != nil {
		return nil, fmt.Errorf("tag not found")
	}

	m := tagToModel(tag)
	lists, err := r.Queries.GetListsByTag(ctx, tag.ID)
	if err != nil {
		return nil, err
	}
	m.Lists = make([]*model.List, len(lists))
	for i, l := range lists {
		m.Lists[i] = listToModel(l)
	}
	return m, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// --- helpers for populating nested fields ---

func (r *Resolver) populateList(ctx context.Context, m *model.List) (*model.List, error) {
	m, err := r.populateListOwner(ctx, m)
	if err != nil {
		return nil, err
	}
	return r.populateListItemsAndTags(ctx, m)
}

func (r *Resolver) populateListOwner(ctx context.Context, m *model.List) (*model.List, error) {
	lid, err := stringToUUID(m.ID)
	if err != nil {
		return nil, err
	}
	list, err := r.Queries.GetListByID(ctx, lid)
	if err != nil {
		return nil, err
	}
	owner, err := r.Queries.GetUserByID(ctx, list.OwnerID)
	if err != nil {
		return nil, err
	}
	m.Owner = userToModel(owner)
	return m, nil
}

func (r *Resolver) populateListItemsAndTags(ctx context.Context, m *model.List) (*model.List, error) {
	lid, err := stringToUUID(m.ID)
	if err != nil {
		return nil, err
	}

	items, err := r.Queries.GetItemsByList(ctx, lid)
	if err != nil {
		return nil, err
	}
	m.Items = make([]*model.Item, len(items))
	for i, item := range items {
		m.Items[i] = itemToModel(item)
	}

	tags, err := r.Queries.GetTagsByList(ctx, lid)
	if err != nil {
		return nil, err
	}
	m.Tags = make([]*model.Tag, len(tags))
	for i, t := range tags {
		m.Tags[i] = tagToModel(t)
	}

	return m, nil
}
