// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recurring.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecurring = `-- name: CreateRecurring :one
INSERT INTO recurring (user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution
`

type CreateRecurringParams struct {
	UserID        pgtype.Int4      `json:"user_id"`
	WalletID      pgtype.Int4      `json:"wallet_id"`
	Type          string           `json:"type"`
	Amount        pgtype.Numeric   `json:"amount"`
	Currency      string           `json:"currency"`
	Description   pgtype.Text      `json:"description"`
	Recurrence    string           `json:"recurrence"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
	NextExecution pgtype.Timestamp `json:"next_execution"`
}

func (q *Queries) CreateRecurring(ctx context.Context, arg CreateRecurringParams) (Recurring, error) {
	row := q.db.QueryRow(ctx, createRecurring,
		arg.UserID,
		arg.WalletID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.Description,
		arg.Recurrence,
		arg.StartDate,
		arg.EndDate,
		arg.NextExecution,
	)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.NextExecution,
	)
	return i, err
}

const deleteRecurring = `-- name: DeleteRecurring :exec
DELETE FROM recurring
WHERE id = $1
`

func (q *Queries) DeleteRecurring(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecurring, id)
	return err
}

const getDueRecurring = `-- name: GetDueRecurring :many
SELECT id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution FROM recurring
WHERE next_execution <= NOW()
  AND (end_date IS NULL OR end_date >= CURRENT_DATE)
ORDER BY next_execution ASC
`

func (q *Queries) GetDueRecurring(ctx context.Context) ([]Recurring, error) {
	rows, err := q.db.Query(ctx, getDueRecurring)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.Recurrence,
			&i.StartDate,
			&i.EndDate,
			&i.NextExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringByID = `-- name: GetRecurringByID :one
SELECT id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution FROM recurring
WHERE id = $1
`

func (q *Queries) GetRecurringByID(ctx context.Context, id int32) (Recurring, error) {
	row := q.db.QueryRow(ctx, getRecurringByID, id)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.NextExecution,
	)
	return i, err
}

const getRecurringByUserID = `-- name: GetRecurringByUserID :many
SELECT id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution FROM recurring
WHERE user_id = $1
ORDER BY next_execution ASC
`

func (q *Queries) GetRecurringByUserID(ctx context.Context, userID pgtype.Int4) ([]Recurring, error) {
	rows, err := q.db.Query(ctx, getRecurringByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.Recurrence,
			&i.StartDate,
			&i.EndDate,
			&i.NextExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecurring = `-- name: UpdateRecurring :one
UPDATE recurring
SET wallet_id = $2, type = $3, amount = $4, currency = $5, description = $6, 
    recurrence = $7, start_date = $8, end_date = $9, next_execution = $10
WHERE id = $1
RETURNING id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution
`

type UpdateRecurringParams struct {
	ID            int32            `json:"id"`
	WalletID      pgtype.Int4      `json:"wallet_id"`
	Type          string           `json:"type"`
	Amount        pgtype.Numeric   `json:"amount"`
	Currency      string           `json:"currency"`
	Description   pgtype.Text      `json:"description"`
	Recurrence    string           `json:"recurrence"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
	NextExecution pgtype.Timestamp `json:"next_execution"`
}

func (q *Queries) UpdateRecurring(ctx context.Context, arg UpdateRecurringParams) (Recurring, error) {
	row := q.db.QueryRow(ctx, updateRecurring,
		arg.ID,
		arg.WalletID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.Description,
		arg.Recurrence,
		arg.StartDate,
		arg.EndDate,
		arg.NextExecution,
	)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.NextExecution,
	)
	return i, err
}

const updateRecurringNextExecution = `-- name: UpdateRecurringNextExecution :one
UPDATE recurring
SET next_execution = $2
WHERE id = $1
RETURNING id, user_id, wallet_id, type, amount, currency, description, recurrence, start_date, end_date, next_execution
`

type UpdateRecurringNextExecutionParams struct {
	ID            int32            `json:"id"`
	NextExecution pgtype.Timestamp `json:"next_execution"`
}

func (q *Queries) UpdateRecurringNextExecution(ctx context.Context, arg UpdateRecurringNextExecutionParams) (Recurring, error) {
	row := q.db.QueryRow(ctx, updateRecurringNextExecution, arg.ID, arg.NextExecution)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Recurrence,
		&i.StartDate,
		&i.EndDate,
		&i.NextExecution,
	)
	return i, err
}
